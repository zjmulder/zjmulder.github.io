<!DOCTYPE html>
<html>
    
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Zachary Mulder | Scraper </title>
        <meta name="description" content="Learning about me">
        <link rel="stylesheet" href="/main.min.css">
        <link rel="stylesheet" href="/assests/plugins/codemirror/codemirror.min.css">
    </head>
    
    <body>
        <div class='content-wrapper'>
            <div class="header-wrapper">
                <div class="menu-wrapper">
                    <div class="menu-name">
                        Zachary Mulder
                    </div>
                    <div class="menu-links">
                        <a href="/index.html">
                            <div class="menu-item">About Me</div>
                        </a>
                        <a href="/pages/projects.html">
                            <div class="menu-item active">Projects</div>
                        </a>
                        <a href="/pages/photography.html">
                            <div class="menu-item">Photography</div>
                        </a>
                        <div class="clear"></div>
                    </div>
                    <div class="clear"></div>
                </div>
            </div>

            <div class='content'>
                <h1>CSGO Scraper &amp; Team Rankings</h1>
                
                <p>
                    I love Counter Strike. I fell in love with the game in December of 2013 when I was peer pressured into trying Global Offensive during winter break at one of my favorite man caves back home. Coming from years of playing Call of Duty, I couldn’t hit an enemy to save my life (“What do you mean I can’t move and shoot?”) but after logging almost 1000 hours in game, achieving the highest competitive rank possible (yes it was when the ranks were bugged, but who keeps track of that), I can say that I’m at least not terrible.
                </p>
                <p>
                    Alongside my love of the playing the game, I also fell in love with watching the game at a professional level. And more importantly, my inner data scientist was alive with excitement. A professional competition where the game took place entirely on a server meant you had perfect knowledge about every action in the game. It’s data heaven.
                </p>
                <p>
                    Turns out, extracting the data from the server into meaningful numbers was harder than I thought.
                    <a href='/assests/downloads/CSGOServer.pdf' download='CSGO Live Predictions.pdf'>I gave it an attempt in Grad School.</a>
                </p>
                <p>
                    So I went back to the drawing board and thought what I really want is to capture every game, even if it’s only at a high level. Enter HLTV. THE place to go for information on anything counter strike related (I swear this isn't a plug). Almost every professional match played is catalogued and analyzed on their website. I thought I had hit the jackpot.
                </p>
                
                <p>
                    But, HLTV doesn’t provide an API or any easy way to export their vast information. I had just started to undertake web development at work, and so I thought I might be able to cobble together a scraper.
                </p>
                
                <!--Step 1-->
                <h2>Step 1: Scraping the <a href='http://www.hltv.org/?pageid=188&matchid=35760'>Page</a></h2>
                <p style="text-align:center;">
                    <img src="/assests/images/StatPage.png" style="width:800px;"/>
                </p>
                <p>
                    This page is exactly what I was looking for. After every game played, a page is created with essentially 3 different sections: Information about the match and how the team performed as a whole, the result of each round played, and stats for each player in the match. The following code, using the java library <a href="https://jsoup.org/">jsoup</a>, returns the center section of the page pictured above under the variable body.
                </p>
                <div class="code">
                    <textarea>//Return the page\Document doc = Jsoup.connect(url).userAgent(userAgent).get();\\//Set the center body of the page\Element body = doc.getElementsByClass("centerNoHeadline").select("div.centerFade").first();
                    </textarea>
                </div>
                <p>
                    From there, the rest of the page was fairly straightforward to scrape. Many of the selectors seemed oddly specific, but it appears much of the page formatting was accomplished using inline styles as opposed to CSS and defined classes. 
                </p>
                <div class="code">
                    <textarea>//Returns all 'Maps' in the series from the top of the page\//Used to group individual games into the overall series (best of 3, best of 5, etc...)\Elements maps = body.select("div[style*=z-index: 1] a[href]");\\//Each row in the overall game stats\Element overview = body.select("div[style*=float:left]").first();\Elements overviewRows = overview.select("div.covGroupBoxContent > div:not([style*=clear:both])");\\//Each icon in 'Round History' with the round outcome\Elements roundResults = body.select("div[style*=margin-top:5px] div[style*=width:49%] img");\\//Each row in the 'Raw stats' section at the bottom of the page\Element statBox = body.select(" > div[style*=clear:both]").last();\Elements statRows = statBox.select("div.covMainBoxContent div[style*=width:606px;height:22px] > div");
                    </textarea>
                </div>
                <p>
                    Great, so now that I had a scraper, I just had to figure out how to access the page for each match. I looked at the URL:
                </p>
                <code>
                    http://www.hltv.org/?pageid=188&amp;matchid=35822
                </code>
                <p>
                    And I figured I could enumerate all values for MatchID at the end of the query string. Unfortunately, MatchID seemed to skip values for 'real' matches and would return inconsistent results when specifying a value that didn't exist in their database. So how do I know which MatchIDs correspond to real matches?
                </p>
                
                <!--Step 0-->
                <h2>Step 0: Find the Golden MatchIDs</h2>
                <p>
                    I took a step back and realized all I had to do was scrape another page, <a href="http://www.hltv.org/?pageid=188">the recent matches statistics page</a>. 
                </p>
                <p>
                    Each row on the page corresponded to one match and its accompanying MatchID as well as other information about the match contained in the statistics page. Scraping this page turned out to be a blessing in disguise. First, now I could easily filter out games to scrape by date (since who needs games back in 2012). Second, I could distinguish if a match was played online, at a LAN event, or during a major. Last, this was an easy way to continue updating my database as new matches were played. I only had to check this list (which is in chronological order), and stop scraping matches that were already in the database (I chose to define that stopping criteria as when an entire page, or 50 matches, were already scrapped).
                </p>
                <div class="code">
                    <textarea>//Return the page\Document doc = Jsoup.connect(url).userAgent(userAgent).get();\\//Get the table and all rows\Element table = doc.getElementsByClass("covMainBoxContent").first();\Elements rows = table.select("a");\\//Loop through each row\for (Element link : rows){\  ...\}
                    </textarea>
                </div>
                
                <!--Step 2-->
                <h2>Step 2: Storing the Data</h2>
                <p style="text-align:center;">
                    <img src="/assests/images/DB.png" style="width:800px;"/>
                </p>
                <p>
                    Next, I created a fairly straight forward database schema and implemented it in SQLite using <a href="http://sqlitebrowser.org/">DB Browser for SQLite</a>. Wholly unremarkable, but there were a few things I managed during scraping that made analysis easier in the future.
                </p>
                <p>
                    <b>Players, Rosters, and Teams</b> - If you follow professional Counter Strike, you know that who is playing for who changes all the time. Players get DDOSed and a team needs a stand-in, teams get bought out and change sponsors, and players are replaced before they can even get comfortable if they don't perform. To capture these changes, I grouped 5 players into a roster indicating their first match played together by StartDate, and their last game played together as EndDate (or NULL if each player's last game was with the current roster, indicating it's currently active). I used the same mechanism for team (or sponsor) to easily tell which roster was currently active with each team. This way, if a team needs to use a different player (and subsequently a different roster), it's tracked separately as opposed to being lumped in with all of their results. I did this by tracking the individual players listed as active for each game.
                </p>
                
                <h2>Step 3: The Model</h2>
                <p>
                    Next, I moved to R to create the Elo based model for ranking the teams. I pulled every match played by each active roster and gave the roster a baseline rating of 1300. To determine a team's score in a given game, I took the number of rounds they won over the total number of rounds played. This conveniently rewarded a blowout win with a higher score while a close game (or tie) would result in a score close to 0.5. From there, I divided the matches into a training set containing 80% of the data, and a test set of 20% to find the optimal multiplier for updating a team's ranking after a match based on minimizing the error in the predicted versus actual score of a match. Using the optimal multiplier, I began cataloguing the predicted outcome against actual outcomes and found that my model has about a 66% change of predicting the correct outcome. While this is a promising result (if I were a betting man, I could probably make a fair profit), I hope to include the model's predictive ability by including more inputs such as the map choice, match venue (online matches versus major tournamnets), and fractional rosters to yield even better results.
                </p>

            </div>
        </div>
        <div class='footer-wrapper'>
            <div class="info-block">
                <div class="info-column w-25">
                    <div class="info-inner text-left">
                        <h4>Contact Me</h4>
                        <p>I live life on the edge. No social media (LinkedIn doesn't count).</p>
                        <div class="contact-email">
                            Email: <a href="mailto:zjmulder@gmail.com?Subject=You%20Seem%20Pretty%20Swell"><b class="accent">zjmulder@gmail.com</b></a>
                        </div>
                        <div>
                            <a href="https://www.linkedin.com/in/zachary-mulder-40585368">Find me on LinkedIn</a>
                        </div>
                    </div>
                </div>
                <div class="info-column w-25">
                    <div class="info-inner text-left">
                        <h4>Things I love for outdoors</h4>
                        <ul>
                            <li>Scarlett, my Cannondale CAAD 8</li>
                            <li>Long johns - The best kept secret from Arizonans</lI>
                            <li>Everything HydroFlask</li>
                            <li>Langly Alpha Pro Camera Bag</li>
                            <li>Garmin Forerunner 235</li>
                            <li>Rhodia Webnotebooks</li>
                        </ul>
                    </div>
                </div>
                <div class="info-column w-25">
                    <div class="info-inner text-left">
                        <h4>Reasons I stay inside</h4>
                        <ul>
                            <li>Oswin, my custom built gaming/coding desktop</li>
                            <li>Counter Strike: Global Offensive</li>
                            <li>Rocket League</li>
                            <li>Overwatch</li>
                            <li><a href="https://www.twitch.tv/timthetatman">twitch.tv/TimTheTatman</a></li>
                            <li>Too many books to list</li>
                        </ul>
                    </div>
                </div>
                <div class="info-column w-25">
                    <div class="info-inner text-left">
                        <h4>Website Design and Icons</h4>
                        <div class="icon-attribution"><p>This website was designed and created by myself from the ground up.</p></div>
                        <div class="icon-attribution">Analytics icons made by <a href="http://www.freepik.com" title="Freepik">Freepik</a> from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a> is licensed by <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a>
                        </div>
                        <div class="icon-attribution">Icons also provided by <a href="http://devicon.fr/">Devicon 2.0</a></div>
                    </div>
                </div>
            </div>
        </div>
    
    </body>
    <footer>
        <script src='/assests/plugins/jquery/jquery-3.1.0.min.js' type='text/javascript'></script>
        <script src="/assests/plugins/codemirror/codemirror.min.js"></script>
        <script src="/assests/plugins/codemirror/modes/clike/clike.min.js"></script>
        
        <script type="text/javascript">
            $(document).ready(function() {
                $('.code>textarea').each(function() {
                    $(this).text($(this).text().trim());
                    CodeMirror.fromTextArea(this, {
                        lineNumbers:true,
                        mode:"text/x-java",
                        readOnly:true,
                        lineSeparator:"\\"
                   }); 
                });
            });
        </script>
    
    </footer>
    
    
</html>